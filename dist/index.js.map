{"version":3,"file":"index.js","sources":["../src/types.ts","../src/errors.js","../src/injector.js","../src/inject.js","../src/bindings.js","../src/provider.js","../src/hooks.js"],"sourcesContent":["export type Token = Function | Object | string | symbol;\r\nexport type Definition = Function | [Function] | [Token, Function];\r\n\r\nexport function isFunction(arg): arg is Function {\r\n  return typeof arg === \"function\";\r\n}\r\n\r\nexport function isObject(arg): arg is Object {\r\n  return arg && typeof arg === \"object\";\r\n}\r\n\r\nexport function isString(arg): arg is string {\r\n  return typeof arg === \"string\";\r\n}\r\n\r\nexport function isSymbol(arg): arg is symbol {\r\n  return typeof arg === \"symbol\";\r\n}\r\n\r\nexport function isToken(arg): arg is Token {\r\n  return isFunction(arg) || isObject(arg) || isString(arg) || isSymbol(arg);\r\n}\r\n\r\nexport function isReactComponent(prototype) {\r\n  return isObject(prototype) && isObject(prototype.isReactComponent);\r\n}\r\n\r\nexport function isValidMetadata(arg): arg is Function {\r\n  return (\r\n    isFunction(arg) &&\r\n    [Object, Function, Number, String, Boolean].indexOf(arg) === -1\r\n  );\r\n}\r\n","import { isFunction, isObject, isReactComponent } from \"./types\";\r\n\r\nexport function getDebugName(value) {\r\n  if (isFunction(value)) {\r\n    return String(value.displayName || value.name);\r\n  }\r\n  if (isObject(value) && isFunction(value.constructor)) {\r\n    return String(value.constructor.name);\r\n  }\r\n  return String(value);\r\n}\r\n\r\nexport function logError(message) {\r\n  try {\r\n    throw new Error(message);\r\n  } catch (e) {\r\n    console.error(e);\r\n  }\r\n}\r\n\r\nexport function logIncorrectBinding(token, binding) {\r\n  const tokenName = getDebugName(token);\r\n  const bindingName = getDebugName(binding);\r\n  logError(`Binding [${tokenName}, ${bindingName}] is incorrect.`);\r\n}\r\n\r\nexport function logNotFoundDependency(token) {\r\n  const name = getDebugName(token);\r\n  logError(\r\n    `Dependency ${name} is not found.\r\nPlease register ${name} in some Provider e.g.\r\n@provider([${name}, ${name}])\r\nclass App extends React.Component { /*...*/ }`\r\n  );\r\n}\r\n\r\nexport function logNotFoundProvider(target) {\r\n  if (isReactComponent(target)) {\r\n    const name = getDebugName(target);\r\n    logError(\r\n      `Provider is not found.\r\n  Please define Provider and set ${name}.contextType = InjectorContext e.g.\r\n  @provider([MyService, MyService])\r\n  class App extends React.Component { /*...*/ }\r\n  class ${name} extends React.Component {\r\n    static contextType = InjectorContext;\r\n  }`\r\n    );\r\n  } else {\r\n    logError(\r\n      `Provider is not found.\r\n  Please define Provider e.g.\r\n  @provider([MyService, MyService])\r\n  class App extends React.Component { /*...*/ }`\r\n    );\r\n  }\r\n}\r\n\r\nexport function logInvalidMetadata(target, token) {\r\n  const tokenName = getDebugName(token);\r\n  const targetName = getDebugName(target);\r\n  logError(\r\n    `${tokenName} is not a valid dependency.\r\nPlease specify ES6 class as property type e.g.\r\nclass MyService {}\r\nclass ${targetName} {\r\n  @inject myService: MyService;\r\n}`\r\n  );\r\n}\r\n","import { Component, createContext } from \"react\";\r\nimport { logNotFoundDependency } from \"./errors\";\r\n/** @typedef {import(\"./types\").Token} Token */\r\n\r\n/** React Context for Injector */\r\nexport const InjectorContext = createContext(null);\r\n\r\n/**\r\n * Dependency injection container\r\n * @internal\r\n */\r\nexport class Injector extends Component {\r\n  /** @type {Injector} */\r\n  _parent;\r\n  /** @type {Map<Token, Function>} */\r\n  _bindingMap;\r\n  /** @type {Map<Token, Object>} */\r\n  _instanceMap;\r\n}\r\n\r\n/**\r\n * Find Injector for passed object and cache it inside this object\r\n * @internal\r\n * @param {Object} target The object in which we inject value\r\n * @returns {Injector}\r\n */\r\nexport function getInjector(target) {\r\n  let injector = target[INJECTOR];\r\n  if (injector) {\r\n    return injector;\r\n  }\r\n  injector = currentInjector || target.context;\r\n  if (injector instanceof Injector) {\r\n    target[INJECTOR] = injector;\r\n    return injector;\r\n  }\r\n  return null;\r\n}\r\n\r\n/** @type {Injector} */\r\nlet currentInjector = null;\r\n\r\n/* istanbul ignore next */\r\nexport const INJECTOR =\r\n  typeof Symbol === \"function\" ? Symbol() : \"__injector__\";\r\n\r\n/**\r\n * Resolve a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @internal\r\n * @param {Injector} injector Injector instance\r\n * @param {Token} token Dependency injection token\r\n * @returns {Object} Resolved class instance\r\n */\r\nexport function getInstance(injector, token) {\r\n  if (registrationQueue.length > 0) {\r\n    registrationQueue.forEach(registration => {\r\n      registration();\r\n    });\r\n    registrationQueue.length = 0;\r\n  }\r\n  while (injector) {\r\n    let instance = injector._instanceMap.get(token);\r\n    if (instance !== undefined) {\r\n      return instance;\r\n    }\r\n    const binding = injector._bindingMap.get(token);\r\n    if (binding) {\r\n      const prevInjector = currentInjector;\r\n      currentInjector = injector;\r\n      try {\r\n        instance = binding(injector);\r\n      } finally {\r\n        currentInjector = prevInjector;\r\n      }\r\n      injector._instanceMap.set(token, instance);\r\n      return instance;\r\n    }\r\n    injector = injector._parent;\r\n  }\r\n  if (__DEV__) {\r\n    logNotFoundDependency(token);\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/** @type {Function[]} */\r\nexport const registrationQueue = [];\r\n","import \"reflect-metadata\";\r\nimport { InjectorContext, getInjector, getInstance } from \"./injector\";\r\nimport { isValidMetadata, isReactComponent, isFunction } from \"./types\";\r\nimport {\r\n  getDebugName,\r\n  logInvalidMetadata,\r\n  logNotFoundProvider,\r\n  logError\r\n} from \"./errors\";\r\n/** @typedef {import(\"./types\").Token} Token */\r\n\r\n/**\r\n * Property decorator that resolves a class instance\r\n * which registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @param {Token | Object} [targetOrToken] Object or Class prototype or dependency injection token\r\n * @param {string | symbol | Function} [keyOrToken] Property key or dependency injection token\r\n */\r\nexport function inject(targetOrToken, keyOrToken) {\r\n  if (isFunction(keyOrToken)) {\r\n    return injectFunction(targetOrToken, keyOrToken);\r\n  }\r\n  /** @type {Token} */\r\n  let token;\r\n  if (!keyOrToken) {\r\n    token = targetOrToken;\r\n    return injectDecorator;\r\n  }\r\n  return injectDecorator(targetOrToken, keyOrToken);\r\n\r\n  function injectDecorator(prototype, key) {\r\n    if (__DEV__) {\r\n      defineContextType(prototype);\r\n    } else {\r\n      prototype.constructor.contextType = InjectorContext;\r\n    }\r\n\r\n    if (!token) {\r\n      token = Reflect.getMetadata(\"design:type\", prototype, key);\r\n      if (__DEV__) {\r\n        if (!isValidMetadata(token)) {\r\n          logInvalidMetadata(targetOrToken, token);\r\n        }\r\n      }\r\n    }\r\n\r\n    const descriptor = {\r\n      configurable: true,\r\n      enumerable: true,\r\n      get() {\r\n        const instance = injectFunction(this, token);\r\n        Object.defineProperty(this, key, {\r\n          enumerable: true,\r\n          writable: true,\r\n          value: instance\r\n        });\r\n        return instance;\r\n      },\r\n      set(instance) {\r\n        Object.defineProperty(this, key, {\r\n          enumerable: true,\r\n          writable: true,\r\n          value: instance\r\n        });\r\n      }\r\n    };\r\n\r\n    Object.defineProperty(prototype, key, descriptor);\r\n\r\n    return descriptor;\r\n  }\r\n}\r\n\r\n/**\r\n * Resolve a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @internal\r\n * @param {Object} target The object in which we inject class instance\r\n * @param {Token} token Dependency injection token\r\n * @returns {Object} Resolved class instance\r\n */\r\nfunction injectFunction(target, token) {\r\n  const injector = getInjector(target);\r\n  if (__DEV__) {\r\n    if (!injector) {\r\n      logNotFoundProvider(target);\r\n    }\r\n  }\r\n  return getInstance(injector, token);\r\n}\r\n\r\n/**\r\n * Set Class.contextType = InjectorContext\r\n * @internal\r\n * @param {Object} prototype React Component prototype\r\n */\r\nfunction defineContextType(prototype) {\r\n  if (isReactComponent(prototype)) {\r\n    const { constructor } = prototype;\r\n    const className = getDebugName(constructor);\r\n    if (constructor.contextType !== InjectorContext) {\r\n      if (constructor.contextType) {\r\n        logError(\r\n          `Decorator tries to overwrite existing ${className}.contextType`\r\n        );\r\n      } else {\r\n        Object.defineProperty(constructor, \"contextType\", {\r\n          get() {\r\n            return InjectorContext;\r\n          },\r\n          set() {\r\n            logError(\r\n              `You are trying to overwrite ${className}.contextType = InjectorContext`\r\n            );\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { INJECTOR, getInstance } from \"./injector\";\r\nimport { isFunction, isToken } from \"./types\";\r\nimport { logIncorrectBinding, logError, getDebugName } from \"./errors\";\r\n/** @typedef {import(\"./types\").Definition} Definition */\r\n/** @typedef {import(\"./types\").Token} Token */\r\n\r\n/**\r\n * Bind type to specified class.\r\n * @param {new (...args) => any} constructor\r\n * @return {Function}\r\n */\r\nexport function toClass(constructor) {\r\n  if (__DEV__) {\r\n    if (!isFunction(constructor)) {\r\n      logError(`Class ${getDebugName(constructor)} is not a valid dependency`);\r\n    }\r\n  }\r\n  return asBinding(injector => {\r\n    const instance = new constructor();\r\n    if (!instance[INJECTOR]) {\r\n      instance[INJECTOR] = injector;\r\n    }\r\n    return instance;\r\n  });\r\n}\r\n\r\n/**\r\n * Bind type to specified factory funciton.\r\n * @param {any} depsOrFactory Dependencies or factory\r\n * @param {Function} [factory] Factory\r\n * @return {Function}\r\n */\r\nexport function toFactory(depsOrFactory, factory) {\r\n  if (__DEV__) {\r\n    if (factory) {\r\n      if (!Array.isArray(depsOrFactory)) {\r\n        logError(`Dependency array ${getDebugName(depsOrFactory)} is invalid`);\r\n      }\r\n      if (!isFunction(factory)) {\r\n        logError(`Factory ${getDebugName(factory)} is not a valid dependency`);\r\n      }\r\n    } else if (!isFunction(depsOrFactory)) {\r\n      logError(\r\n        `Factory ${getDebugName(depsOrFactory)} is not a valid dependency`\r\n      );\r\n    }\r\n  }\r\n  return asBinding(\r\n    factory\r\n      ? injector =>\r\n          factory(...depsOrFactory.map(token => getInstance(injector, token)))\r\n      : depsOrFactory\r\n  );\r\n}\r\n\r\n/**\r\n * Bind type to specified value.\r\n * @param {any} value\r\n * @return {Function}\r\n */\r\nexport function toValue(value) {\r\n  if (__DEV__) {\r\n    if (value === undefined) {\r\n      logError(`Please specify some value`);\r\n    }\r\n  }\r\n  return asBinding(() => value);\r\n}\r\n\r\n/**\r\n * Bind type to existing instance located by token.\r\n * @param {Token} token\r\n * @return {Function}\r\n */\r\nexport function toExisting(token) {\r\n  if (__DEV__) {\r\n    if (!isFunction(token)) {\r\n      logError(\r\n        `Token ${getDebugName(token)} is not a valid dependency injection token`\r\n      );\r\n    }\r\n  }\r\n  return asBinding(injector => getInstance(injector, token));\r\n}\r\n\r\n/* istanbul ignore next */\r\nconst IS_BINDING = typeof Symbol === \"function\" ? Symbol() : \"__binding__\";\r\n\r\n/**\r\n * Mark function as binding function.\r\n * @internal\r\n * @param {Function} binding\r\n * @returns {Function}\r\n */\r\nfunction asBinding(binding) {\r\n  binding[IS_BINDING] = true;\r\n  return binding;\r\n}\r\n\r\n/**\r\n * Add bindings to bindings Map\r\n * @internal\r\n * @param {Map<Token, Function>} bindingMap\r\n * @param {Definition[]} definitions\r\n */\r\nexport function addBindings(bindingMap, definitions) {\r\n  definitions.forEach(definition => {\r\n    let token, binding;\r\n    if (Array.isArray(definition)) {\r\n      [token, binding = token] = definition;\r\n    } else {\r\n      token = binding = definition;\r\n    }\r\n    if (__DEV__) {\r\n      if (!isToken(token) || !isFunction(binding)) {\r\n        logIncorrectBinding(token, binding);\r\n      }\r\n    }\r\n    // @ts-ignore\r\n    bindingMap.set(token, binding[IS_BINDING] ? binding : toClass(binding));\r\n  });\r\n}\r\n","import { createElement } from \"react\";\r\nimport hoistNonReactStatics from \"hoist-non-react-statics\";\r\nimport { Injector, InjectorContext, registrationQueue } from \"./injector\";\r\nimport { addBindings } from \"./bindings\";\r\nimport { isObject, isFunction } from \"./types\";\r\nimport { logError, getDebugName } from \"./errors\";\r\n/** @typedef {import(\"./types\").Definition} Definition */\r\n/** @typedef {import(\"./types\").Token} Token */\r\n\r\n/**\r\n * HOC that registers dependency injection bindings in scope of decorated component\r\n * @param {...Definition} definitions Dependency injection configuration\r\n */\r\nexport const provider = (...definitions) => Wrapped => {\r\n  /** @type {Map<Token, Function>} */\r\n  const bindingMap = new Map();\r\n\r\n  addBindings(bindingMap, definitions);\r\n\r\n  class Provider extends Injector {\r\n    _parent = this.context;\r\n    _bindingMap = bindingMap;\r\n    _instanceMap = new Map();\r\n\r\n    componentWillUnmount() {\r\n      this._instanceMap.forEach(instance => {\r\n        if (isObject(instance) && isFunction(instance.dispose)) {\r\n          instance.dispose();\r\n        }\r\n      });\r\n    }\r\n\r\n    render() {\r\n      return createElement(\r\n        InjectorContext.Provider,\r\n        { value: this },\r\n        createElement(Wrapped, this.props)\r\n      );\r\n    }\r\n\r\n    static WrappedComponent = Wrapped;\r\n\r\n    /**\r\n     * Register dependency injection bindings in scope of decorated class\r\n     * @param {...Definition} definitions Dependency injection configuration\r\n     */\r\n    static register(...definitions) {\r\n      addBindings(bindingMap, definitions);\r\n    }\r\n  }\r\n\r\n  if (__DEV__) {\r\n    Provider.displayName = `Provider(${Wrapped.displayName || Wrapped.name})`;\r\n\r\n    Object.defineProperty(Provider, \"contextType\", {\r\n      get() {\r\n        return InjectorContext;\r\n      },\r\n      set() {\r\n        logError(\r\n          `You are trying to overwrite ${\r\n            Provider.displayName\r\n          }.contextType = InjectorContext`\r\n        );\r\n      }\r\n    });\r\n  } else {\r\n    Provider.contextType = InjectorContext;\r\n  }\r\n\r\n  // static fields from component should be visible on the generated Consumer\r\n  return hoistNonReactStatics(Provider, Wrapped);\r\n};\r\n\r\n/**\r\n * Register class in specified provider.\r\n * @typedef {{ register(constructor: Function): void }} Provider\r\n * @param {() => Provider} getProvider Function that returns some provider\r\n * @param {Function} [binding] Dependency injection binding\r\n */\r\nexport const registerIn = (getProvider, binding) => constructor => {\r\n  registrationQueue.push(() => {\r\n    if (__DEV__) {\r\n      const provider = getProvider();\r\n      if (!isFunction(provider) || !(provider.prototype instanceof Injector)) {\r\n        logError(\r\n          `${getDebugName(provider)} is not a valid Provider. Please use:\\n` +\r\n            `@registerIn(() => MyProvider)\\n` +\r\n            `class ${getDebugName(constructor)} {}\\n`\r\n        );\r\n      } else {\r\n        provider.register(binding ? [constructor, binding] : constructor);\r\n      }\r\n    } else {\r\n      getProvider().register(binding ? [constructor, binding] : constructor);\r\n    }\r\n  });\r\n  return constructor;\r\n};\r\n","import { useContext, useRef } from \"react\";\r\nimport { InjectorContext, getInstance } from \"./injector\";\r\nimport { logNotFoundProvider } from \"./errors\";\r\n/** @typedef {import(\"./types\").Token} Token */\r\n\r\n/**\r\n * React hook for resolving a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @param {Token} token Dependency injection token\r\n * @returns {Object} Resolved class instance\r\n */\r\nexport function useInstance(token) {\r\n  const ref = useRef(null);\r\n  const injector = useContext(InjectorContext);\r\n  if (__DEV__) {\r\n    if (!injector) {\r\n      logNotFoundProvider();\r\n    }\r\n  }\r\n  return ref.current || (ref.current = getInstance(injector, token));\r\n}\r\n\r\n/**\r\n * React hook for resolving a class instances that registered by some Provider in hierarchy.\r\n * Instances are cached in Provider that registers it's classes.\r\n * @param {...Token} tokens Dependency injection tokens\r\n * @returns {Object[]} Resolved class instances\r\n */\r\nexport function useInstances(...tokens) {\r\n  const ref = useRef(null);\r\n  const injector = useContext(InjectorContext);\r\n  if (__DEV__) {\r\n    if (!injector) {\r\n      logNotFoundProvider();\r\n    }\r\n  }\r\n  return (\r\n    ref.current ||\r\n    (ref.current = tokens.map(token => getInstance(injector, token)))\r\n  );\r\n}\r\n"],"names":["createContext","tslib_1.__extends","Component","createElement","useRef","useContext"],"mappings":";;;;;;;;;;;;;SAGgB,UAAU,CAAC,GAAG;EAC5B,OAAO,OAAO,GAAG,KAAK,UAAU,CAAC;CAClC;SAEe,QAAQ,CAAC,GAAG;EAC1B,OAAO,GAAG,IAAI,OAAO,GAAG,KAAK,QAAQ,CAAC;CACvC;SAEe,QAAQ,CAAC,GAAG;EAC1B,OAAO,OAAO,GAAG,KAAK,QAAQ,CAAC;CAChC;SAEe,QAAQ,CAAC,GAAG;EAC1B,OAAO,OAAO,GAAG,KAAK,QAAQ,CAAC;CAChC;SAEe,OAAO,CAAC,GAAG;EACzB,OAAO,UAAU,CAAC,GAAG,CAAC,IAAI,QAAQ,CAAC,GAAG,CAAC,IAAI,QAAQ,CAAC,GAAG,CAAC,IAAI,QAAQ,CAAC,GAAG,CAAC,CAAC;CAC3E;SAEe,gBAAgB,CAAC,SAAS;EACxC,OAAO,QAAQ,CAAC,SAAS,CAAC,IAAI,QAAQ,CAAC,SAAS,CAAC,gBAAgB,CAAC,CAAC;CACpE;SAEe,eAAe,CAAC,GAAG;EACjC;IACE,UAAU,CAAC,GAAG,CAAC;IACf,CAAC,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC;EAAC,EAC/D;EACH;;SC9Be,YAAY,CAAC,KAAK;EAChC,IAAI,UAAU,CAAC,KAAK,CAAC,EAAE;IACrB,OAAO,MAAM,CAAC,KAAK,CAAC,WAAW,IAAI,KAAK,CAAC,IAAI,CAAC,CAAC;GAChD;EACD,IAAI,QAAQ,CAAC,KAAK,CAAC,IAAI,UAAU,CAAC,KAAK,CAAC,WAAW,CAAC,EAAE;IACpD,OAAO,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;GACvC;EACD,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC;CACtB;SAEe,QAAQ,CAAC,OAAO;EAC9B,IAAI;IACF,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC;GAC1B,CAAC,OAAO,CAAC,EAAE;IACV,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;GAClB;CACF;SAEe,mBAAmB,CAAC,KAAK,EAAE,OAAO;EAChD,IAAM,SAAS,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC;EACtC,IAAM,WAAW,GAAG,YAAY,CAAC,OAAO,CAAC,CAAC;EAC1C,QAAQ,CAAC,cAAY,SAAS,UAAK,WAAW,oBAAiB,CAAC,CAAC;CAClE;SAEe,qBAAqB,CAAC,KAAK;EACzC,IAAM,IAAI,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC;EACjC,QAAQ;IACN;MAAc,IAAI;;MACJ,IAAI;;MACT,IAAI;;MAAK,IAAI;;EACoB,CAC3C,CAAC;CACH;SAEe,mBAAmB,CAAC,MAAM;EACxC,IAAI,gBAAgB,CAAC,MAAM,CAAC,EAAE;IAC5B,IAAM,MAAI,GAAG,YAAY,CAAC,MAAM,CAAC,CAAC;IAClC,QAAQ;MACN;QAC6B,MAAI;;QAG7B,MAAI;oFAEV,AACE;MACH;SAAM;IACL,QAAQ;MACN;IAG0C,CAC3C,CAAC;GACH;CACF;SAEe,kBAAkB,CAAC,MAAM,EAAE,KAAK;EAC9C,IAAM,SAAS,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC;EACtC,IAAM,UAAU,GAAG,YAAY,CAAC,MAAM,CAAC,CAAC;EACxC,QAAQ;IACH,SAAS;;MAGR,UAAU;;EAEhB,CACC,CAAC;EACH;;ACnED;;IAGa,eAAe,GAAGA,mBAAa,CAAC,IAAI,CAAC,CAAC;;;;;AAMnD;EAA8BC,oCAAS;EAAvC;;GAOC;EAAD,eAAC;EAPD,CAA8BC,eAAS,EAOtC;;;;;;;SAQe,WAAW,CAAC,MAAM;EAChC,IAAI,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;EAChC,IAAI,QAAQ,EAAE;IACZ,OAAO,QAAQ,CAAC;GACjB;EACD,QAAQ,GAAG,eAAe,IAAI,MAAM,CAAC,OAAO,CAAC;EAC7C,IAAI,QAAQ,YAAY,QAAQ,EAAE;IAChC,MAAM,CAAC,QAAQ,CAAC,GAAG,QAAQ,CAAC;IAC5B,OAAO,QAAQ,CAAC;GACjB;EACD,OAAO,IAAI,CAAC;CACb;;AAGD,IAAI,eAAe,GAAG,IAAI,CAAC;;AAGpB,IAAM,QAAQ,GACnB,OAAO,MAAM,KAAK,UAAU,GAAG,MAAM,EAAE,GAAG,cAAc,CAAC;;;;;;;;;SAU3C,WAAW,CAAC,QAAQ,EAAE,KAAK;EACzC,IAAI,iBAAiB,CAAC,MAAM,GAAG,CAAC,EAAE;IAChC,iBAAiB,CAAC,OAAO,CAAC,SAAA,YAAY;MACpC,YAAY,EAAE,CAAC;KAChB,CAAC,CAAC;IACH,iBAAiB,CAAC,MAAM,GAAG,CAAC,CAAC;GAC9B;EACD,OAAO,QAAQ,EAAE;IACf,IAAI,QAAQ,GAAG,QAAQ,CAAC,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;IAChD,IAAI,QAAQ,KAAK,SAAS,EAAE;MAC1B,OAAO,QAAQ,CAAC;KACjB;IACD,IAAM,OAAO,GAAG,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;IAChD,IAAI,OAAO,EAAE;MACX,IAAM,YAAY,GAAG,eAAe,CAAC;MACrC,eAAe,GAAG,QAAQ,CAAC;MAC3B,IAAI;QACF,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC;OAC9B,SAAS;QACR,eAAe,GAAG,YAAY,CAAC;OAChC;MACD,QAAQ,CAAC,YAAY,CAAC,GAAG,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;MAC3C,OAAO,QAAQ,CAAC;KACjB;IACD,QAAQ,GAAG,QAAQ,CAAC,OAAO,CAAC;GAC7B;EACD,2CAAa;IACX,qBAAqB,CAAC,KAAK,CAAC,CAAC;GAC9B;EACD,OAAO,SAAS,CAAC;CAClB;;AAGM,IAAM,iBAAiB,GAAG,EAAE,EAAC;;AC9EpC;;;;;;;;SASgB,MAAM,CAAC,aAAa,EAAE,UAAU;EAC9C,IAAI,UAAU,CAAC,UAAU,CAAC,EAAE;IAC1B,OAAO,cAAc,CAAC,aAAa,EAAE,UAAU,CAAC,CAAC;GAClD;;EAED,IAAI,KAAK,CAAC;EACV,IAAI,CAAC,UAAU,EAAE;IACf,KAAK,GAAG,aAAa,CAAC;IACtB,OAAO,eAAe,CAAC;GACxB;EACD,OAAO,eAAe,CAAC,aAAa,EAAE,UAAU,CAAC,CAAC;EAElD,SAAS,eAAe,CAAC,SAAS,EAAE,GAAG;IACrC,2CAAa;MACX,iBAAiB,CAAC,SAAS,CAAC,CAAC;KAC9B,MAAM;MACL,SAAS,CAAC,WAAW,CAAC,WAAW,GAAG,eAAe,CAAC;KACrD;IAED,IAAI,CAAC,KAAK,EAAE;MACV,KAAK,GAAG,OAAO,CAAC,WAAW,CAAC,aAAa,EAAE,SAAS,EAAE,GAAG,CAAC,CAAC;MAC3D,2CAAa;QACX,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,EAAE;UAC3B,kBAAkB,CAAC,aAAa,EAAE,KAAK,CAAC,CAAC;SAC1C;OACF;KACF;IAED,IAAM,UAAU,GAAG;MACjB,YAAY,EAAE,IAAI;MAClB,UAAU,EAAE,IAAI;MAChB,GAAG;QACD,IAAM,QAAQ,GAAG,cAAc,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAC7C,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,GAAG,EAAE;UAC/B,UAAU,EAAE,IAAI;UAChB,QAAQ,EAAE,IAAI;UACd,KAAK,EAAE,QAAQ;SAChB,CAAC,CAAC;QACH,OAAO,QAAQ,CAAC;OACjB;MACD,GAAG,WAAC,QAAQ;QACV,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,GAAG,EAAE;UAC/B,UAAU,EAAE,IAAI;UAChB,QAAQ,EAAE,IAAI;UACd,KAAK,EAAE,QAAQ;SAChB,CAAC,CAAC;OACJ;KACF,CAAC;IAEF,MAAM,CAAC,cAAc,CAAC,SAAS,EAAE,GAAG,EAAE,UAAU,CAAC,CAAC;IAElD,OAAO,UAAU,CAAC;GACnB;CACF;;;;;;;;;AAUD,SAAS,cAAc,CAAC,MAAM,EAAE,KAAK;EACnC,IAAM,QAAQ,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC;EACrC,2CAAa;IACX,IAAI,CAAC,QAAQ,EAAE;MACb,mBAAmB,CAAC,MAAM,CAAC,CAAC;KAC7B;GACF;EACD,OAAO,WAAW,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;CACrC;;;;;;AAOD,SAAS,iBAAiB,CAAC,SAAS;EAClC,IAAI,gBAAgB,CAAC,SAAS,CAAC,EAAE;IACvB,IAAA,mCAAW,CAAe;IAClC,IAAM,WAAS,GAAG,YAAY,CAAC,WAAW,CAAC,CAAC;IAC5C,IAAI,WAAW,CAAC,WAAW,KAAK,eAAe,EAAE;MAC/C,IAAI,WAAW,CAAC,WAAW,EAAE;QAC3B,QAAQ;UACN;YAAyC,WAAS;0BAAc,AAChE;UACH;aAAM;QACL,MAAM,CAAC,cAAc,CAAC,WAAW,EAAE,aAAa,EAAE;UAChD,GAAG;YACD,OAAO,eAAe,CAAC;WACxB;UACD,GAAG;;YACD,EACE;gBAA+B,WAAS;gDAAgC,AACxE;;WACH;SACF,CAAC,CAAC;OACJ;KACF;GACF;EACF;;ACpHD;;;;;;;SAQgB,OAAO,CAAC,WAAW;EACjC,2CAAa;IACX,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,EAAE;MAC5B,QAAQ;QAAC,WAAS,YAAY,CAAC,WAAW,CAAC,+BAA4B,AAAE;QAC1E;KACF;;EACD,OAAO,SAAS,CAAC,SAAA,QAAQ;IACvB,IAAM,QAAQ,GAAG,IAAI,WAAW,EAAE,CAAC;IACnC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE;MACvB,QAAQ,CAAC,QAAQ,CAAC,GAAG,QAAQ,CAAC;KAC/B;IACD,OAAO,QAAQ,CAAC;GACjB,CAAC,CAAC;CACJ;;;;;;;SAQe,SAAS,CAAC,aAAa,EAAE,OAAO;EAC9C,2CAAa;IACX,IAAI,OAAO,EAAE;MACX,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,aAAa,CAAC,EAAE;QACjC,QAAQ;UAAC,sBAAoB,YAAY,CAAC,aAAa,CAAC,gBAAa,AAAE;UACxE;;MACD,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,EAAE;QACxB,QAAQ;UAAC,aAAW,YAAY,CAAC,OAAO,CAAC,+BAA4B,AAAE;UACxE;OACF;WAAM,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC,EAAE;MACrC,QAAQ;QACN,aAAW,YAAY,CAAC,aAAa,CAAC,+BAA4B,AAClE;QACH;KACF;;EACD,OAAO,SAAS;IACd,OAAO;QACH,SAAA,QAAQ;UACN,OAAA,OAAO;;YAAI,aAAa,CAAC,GAAG,CAAC,SAAA,KAAK;cAAI,OAAA,WAAW,CAAC,QAAQ,EAAE,KAAK,CAAC;aAAA;UAAC;SAAC;QACtE;EAAa,CAClB,CAAC;CACH;;;;;;SAOe,OAAO,CAAC,KAAK;EAC3B,2CAAa;IACX,IAAI,KAAK,KAAK,SAAS,EAAE;MACvB,QAAQ,CAAC,2BAA2B,CAAC,CAAC;KACvC;GACF;EACD,OAAO,SAAS,CAAC;IAAM,OAAA,KAAK;GAAA,CAAC,CAAC;CAC/B;;;;;;SAOe,UAAU,CAAC,KAAK;EAC9B,2CAAa;IACX,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE;MACtB,QAAQ;QACN;UAAS,YAAY,CAAC,KAAK,CAAC;sDAA4C,AACxE;QACH;KACF;;EACD,OAAO,SAAS,CAAC,SAAA,QAAQ;IAAI,OAAA,WAAW,CAAC,QAAQ,EAAE,KAAK,CAAC;GAAA,CAAC,CAAC;CAC5D;;AAGD,IAAM,UAAU,GAAG,OAAO,MAAM,KAAK,UAAU,GAAG,MAAM,EAAE,GAAG,aAAa,CAAC;;;;;;;AAQ3E,SAAS,SAAS,CAAC,OAAO;EACxB,OAAO,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC;EAC3B,OAAO,OAAO,CAAC;CAChB;;;;;;;SAQe,WAAW,CAAC,UAAU,EAAE,WAAW;EACjD,WAAW,CAAC,OAAO,CAAC,SAAA,UAAU;;IAC5B,IAAI,KAAK,EAAE,OAAO,CAAC;IACnB,IAAI,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE;OAC5B,sBAAK;SAAE,mBAAe;SAAf,qCAAe,CAAe;KACvC,MAAM;MACL,KAAK,GAAG,OAAO,GAAG,UAAU,CAAC;KAC9B;IACD,2CAAa;MACX,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,EAAE;QAC3C,mBAAmB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;OACrC;KACF;;IAED,UAAU,CAAC,GAAG,CAAC,KAAK,EAAE,OAAO,CAAC,UAAU,CAAC,GAAG,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC;GACzE,CAAC,CAAC;EACJ;;ACnHD;;;;;;AAOA,IAAa,QAAQ,GAAG;EAAC,qBAAc;OAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;IAAd,gCAAc;;EAAK,OAAA,SAAA,OAAO;;IAEjD,IAAM,UAAU,GAAG,IAAI,GAAG,EAAE,CAAC;IAE7B,WAAW,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC;IAErC;MAAuBD,oCAAQ;MAA/B;QAAA,uEA8BC;QA7BC,aAAO,GAAG,KAAI,CAAC,OAAO,CAAC;QACvB,iBAAW,GAAG,UAAU,CAAC;QACzB,kBAAY,GAAG,IAAI,GAAG,EAAE,CAAC;;OA2B1B;MAzBC,uCAAoB,GAApB;QACE,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,SAAA,QAAQ;UAChC,IAAI,QAAQ,CAAC,QAAQ,CAAC,IAAI,UAAU,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE;YACtD,QAAQ,CAAC,OAAO,EAAE,CAAC;WACpB;SACF,CAAC,CAAC;OACJ;MAED,yBAAM,GAAN;QACE,OAAOE,mBAAa;UAClB,eAAe,CAAC,QAAQ;UACxB,EAAE,KAAK,EAAE,IAAI,EAAE;UACfA,mBAAa,CAAC,OAAO,EAAE,IAAI,CAAC,KAAK,CAAC,AAClC;SACH;;;;;;MAQM,iBAAQ,GAAf;QAAgB,qBAAc;aAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;UAAd,gCAAc;;QAC5B,WAAW,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC;OACtC;MARM,yBAAgB,GAAG,OAAO,CAAC;MASpC,eAAC;MAAA,CA9BsB,QAAQ,EA8B9B;IAED,2CAAa;MACX,QAAQ,CAAC,WAAW;QAAG,eAAY,OAAO,CAAC,WAAW,IAAI,OAAO,CAAC,IAAI,OAAG,CAAC;MAE1E,MAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,aAAa,EAAE;QAC7C,GAAG;UACD,OAAO,eAAe,CAAC;SACxB;QACD,GAAG;;UACD,EACE;cACE,QAAQ,CAAC,WAAW;8CACU,AAChC;YACH;SACF,AAAE;SACJ;WAAM;MACL,QAAQ,CAAC,WAAW,GAAG,eAAe,CAAC;KACxC;;IAGD,OAAO,oBAAoB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;GAChD;CAAA,CAAC;;;;;;;IAQW,UAAU,GAAG,SAAC,WAAW,EAAE,OAAO;EAAK,OAAA,SAAA,WAAW;IAC7D,iBAAiB,CAAC,IAAI,CAAC;MACrB,2CAAa;QACX,IAAM,UAAQ,GAAG,WAAW,EAAE,CAAC;;GAC/B,OAAI,CAAC,UAAU,CAAC,UAAQ,CAAC;UAAI,EAAE,UAAQ,CAAC,SAAS,YAAY,QAAQ,CAAC;;UACpE,QAAQ;YACH,YAAY,CAAC,UAAQ,CAAC;uDAAyC;cAChE,iCAAiC;eACjC,WAAS,YAAY,CAAC,WAAW,CAAC,UAAO,CAAA,AAC3C;YACH;eAAM;UACL,UAAQ,CAAC,QAAQ,CAAC,OAAO,GAAG,CAAC,WAAW,EAAE,OAAO,CAAC,GAAG,WAAW,CAAC,CAAC;SACnE;OACF,MAAM;QACL,WAAW,EAAE,CAAC,QAAQ,CAAC,OAAO,GAAG,CAAC,WAAW,EAAE,OAAO,CAAC,GAAG,WAAW,CAAC,CAAC;OACxE;KACF,CAAC,CAAC;IACH,OAAO,WAAW,CAAC;GACpB;CAAA;;AC/FD;;;;;;;SAQgB,WAAW,CAAC,KAAK;EAC/B,IAAM,GAAG,GAAGC,YAAM,CAAC,IAAI,CAAC,CAAC;EACzB,IAAM,QAAQ,GAAGC,gBAAU,CAAC,eAAe,CAAC,CAAC;EAC7C,2CAAa;IACX,IAAI,CAAC,QAAQ,EAAE;MACb,mBAAmB,EAAE,CAAC;KACvB;GACF;EACD,OAAO,GAAG,CAAC,OAAO,KAAK,GAAG,CAAC,OAAO,GAAG,WAAW,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC,CAAC;CACpE;;;;;;;AAQD,SAAgB,YAAY;EAAC,gBAAS;OAAT,UAAS,EAAT,qBAAS,EAAT,IAAS;IAAT,2BAAS;;EACpC,IAAM,GAAG,GAAGD,YAAM,CAAC,IAAI,CAAC,CAAC;EACzB,IAAM,QAAQ,GAAGC,gBAAU,CAAC,eAAe,CAAC,CAAC;EAC7C,2CAAa;IACX,IAAI,CAAC,QAAQ,EAAE;MACb,mBAAmB,EAAE,CAAC;KACvB;GACF;EACD;IACE,GAAG,CAAC,OAAO;KACV,GAAG,CAAC,OAAO,GAAG,MAAM,CAAC,GAAG,CAAC,SAAA,KAAK;MAAI,OAAA,WAAW,CAAC,QAAQ,EAAE,KAAK,CAAC;KAAA,CAAC;EAAC,EACjE;EACH;;;;;;;;;;;;;;;"}