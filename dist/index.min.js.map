{"version":3,"file":"index.min.js","sources":["../src/types.ts","../src/injector.js","../src/inject.js","../src/bindings.js","../src/provider.js","../src/hooks.js"],"sourcesContent":["export type Token = Function | Object | string | symbol;\r\nexport type Definition = Function | [Function] | [Token, Function];\r\n\r\nexport function isFunction(arg): arg is Function {\r\n  return typeof arg === \"function\";\r\n}\r\n\r\nexport function isObject(arg): arg is Object {\r\n  return arg && typeof arg === \"object\";\r\n}\r\n\r\nexport function isString(arg): arg is string {\r\n  return typeof arg === \"string\";\r\n}\r\n\r\nexport function isSymbol(arg): arg is symbol {\r\n  return typeof arg === \"symbol\";\r\n}\r\n\r\nexport function isToken(arg): arg is Token {\r\n  return isFunction(arg) || isObject(arg) || isString(arg) || isSymbol(arg);\r\n}\r\n\r\nexport function isReactComponent(prototype) {\r\n  return isObject(prototype) && isObject(prototype.isReactComponent);\r\n}\r\n\r\nexport function isValidMetadata(arg): arg is Function {\r\n  return (\r\n    isFunction(arg) &&\r\n    [Object, Function, Number, String, Boolean].indexOf(arg) === -1\r\n  );\r\n}\r\n","import { Component, createContext } from \"react\";\r\nimport { logNotFoundDependency } from \"./errors\";\r\n/** @typedef {import(\"./types\").Token} Token */\r\n\r\n/** React Context for Injector */\r\nexport const InjectorContext = createContext(null);\r\n\r\n/**\r\n * Dependency injection container\r\n * @internal\r\n */\r\nexport class Injector extends Component {\r\n  /** @type {Injector} */\r\n  _parent;\r\n  /** @type {Map<Token, Function>} */\r\n  _bindingMap;\r\n  /** @type {Map<Token, Object>} */\r\n  _instanceMap;\r\n}\r\n\r\n/**\r\n * Find Injector for passed object and cache it inside this object\r\n * @internal\r\n * @param {Object} target The object in which we inject value\r\n * @returns {Injector}\r\n */\r\nexport function getInjector(target) {\r\n  let injector = target[INJECTOR];\r\n  if (injector) {\r\n    return injector;\r\n  }\r\n  injector = currentInjector || target.context;\r\n  if (injector instanceof Injector) {\r\n    target[INJECTOR] = injector;\r\n    return injector;\r\n  }\r\n  return null;\r\n}\r\n\r\n/** @type {Injector} */\r\nlet currentInjector = null;\r\n\r\n/* istanbul ignore next */\r\nexport const INJECTOR =\r\n  typeof Symbol === \"function\" ? Symbol() : \"__injector__\";\r\n\r\n/**\r\n * Resolve a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @internal\r\n * @param {Injector} injector Injector instance\r\n * @param {Token} token Dependency injection token\r\n * @returns {Object} Resolved class instance\r\n */\r\nexport function getInstance(injector, token) {\r\n  if (registrationQueue.length > 0) {\r\n    registrationQueue.forEach(registration => {\r\n      registration();\r\n    });\r\n    registrationQueue.length = 0;\r\n  }\r\n  while (injector) {\r\n    let instance = injector._instanceMap.get(token);\r\n    if (instance !== undefined) {\r\n      return instance;\r\n    }\r\n    const binding = injector._bindingMap.get(token);\r\n    if (binding) {\r\n      const prevInjector = currentInjector;\r\n      currentInjector = injector;\r\n      try {\r\n        instance = binding(injector);\r\n      } finally {\r\n        currentInjector = prevInjector;\r\n      }\r\n      injector._instanceMap.set(token, instance);\r\n      return instance;\r\n    }\r\n    injector = injector._parent;\r\n  }\r\n  if (__DEV__) {\r\n    logNotFoundDependency(token);\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/** @type {Function[]} */\r\nexport const registrationQueue = [];\r\n","import \"reflect-metadata\";\r\nimport { InjectorContext, getInjector, getInstance } from \"./injector\";\r\nimport { isValidMetadata, isReactComponent, isFunction } from \"./types\";\r\nimport {\r\n  getDebugName,\r\n  logInvalidMetadata,\r\n  logNotFoundProvider,\r\n  logError\r\n} from \"./errors\";\r\n/** @typedef {import(\"./types\").Token} Token */\r\n\r\n/**\r\n * Property decorator that resolves a class instance\r\n * which registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @param {Token | Object} [targetOrToken] Object or Class prototype or dependency injection token\r\n * @param {string | symbol | Function} [keyOrToken] Property key or dependency injection token\r\n */\r\nexport function inject(targetOrToken, keyOrToken) {\r\n  if (isFunction(keyOrToken)) {\r\n    return injectFunction(targetOrToken, keyOrToken);\r\n  }\r\n  /** @type {Token} */\r\n  let token;\r\n  if (!keyOrToken) {\r\n    token = targetOrToken;\r\n    return injectDecorator;\r\n  }\r\n  return injectDecorator(targetOrToken, keyOrToken);\r\n\r\n  function injectDecorator(prototype, key) {\r\n    if (__DEV__) {\r\n      defineContextType(prototype);\r\n    } else {\r\n      prototype.constructor.contextType = InjectorContext;\r\n    }\r\n\r\n    if (!token) {\r\n      token = Reflect.getMetadata(\"design:type\", prototype, key);\r\n      if (__DEV__) {\r\n        if (!isValidMetadata(token)) {\r\n          logInvalidMetadata(targetOrToken, token);\r\n        }\r\n      }\r\n    }\r\n\r\n    const descriptor = {\r\n      configurable: true,\r\n      enumerable: true,\r\n      get() {\r\n        const instance = injectFunction(this, token);\r\n        Object.defineProperty(this, key, {\r\n          enumerable: true,\r\n          writable: true,\r\n          value: instance\r\n        });\r\n        return instance;\r\n      },\r\n      set(instance) {\r\n        Object.defineProperty(this, key, {\r\n          enumerable: true,\r\n          writable: true,\r\n          value: instance\r\n        });\r\n      }\r\n    };\r\n\r\n    Object.defineProperty(prototype, key, descriptor);\r\n\r\n    return descriptor;\r\n  }\r\n}\r\n\r\n/**\r\n * Resolve a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @internal\r\n * @param {Object} target The object in which we inject class instance\r\n * @param {Token} token Dependency injection token\r\n * @returns {Object} Resolved class instance\r\n */\r\nfunction injectFunction(target, token) {\r\n  const injector = getInjector(target);\r\n  if (__DEV__) {\r\n    if (!injector) {\r\n      logNotFoundProvider(target);\r\n    }\r\n  }\r\n  return getInstance(injector, token);\r\n}\r\n\r\n/**\r\n * Set Class.contextType = InjectorContext\r\n * @internal\r\n * @param {Object} prototype React Component prototype\r\n */\r\nfunction defineContextType(prototype) {\r\n  if (isReactComponent(prototype)) {\r\n    const { constructor } = prototype;\r\n    const className = getDebugName(constructor);\r\n    if (constructor.contextType !== InjectorContext) {\r\n      if (constructor.contextType) {\r\n        logError(\r\n          `Decorator tries to overwrite existing ${className}.contextType`\r\n        );\r\n      } else {\r\n        Object.defineProperty(constructor, \"contextType\", {\r\n          get() {\r\n            return InjectorContext;\r\n          },\r\n          set() {\r\n            logError(\r\n              `You are trying to overwrite ${className}.contextType = InjectorContext`\r\n            );\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { INJECTOR, getInstance } from \"./injector\";\r\nimport { isFunction, isToken } from \"./types\";\r\nimport { logIncorrectBinding, logError, getDebugName } from \"./errors\";\r\n/** @typedef {import(\"./types\").Definition} Definition */\r\n/** @typedef {import(\"./types\").Token} Token */\r\n\r\n/**\r\n * Bind type to specified class.\r\n * @param {new (...args) => any} constructor\r\n * @return {Function}\r\n */\r\nexport function toClass(constructor) {\r\n  if (__DEV__) {\r\n    if (!isFunction(constructor)) {\r\n      logError(`Class ${getDebugName(constructor)} is not a valid dependency`);\r\n    }\r\n  }\r\n  return asBinding(injector => {\r\n    const instance = new constructor();\r\n    if (!instance[INJECTOR]) {\r\n      instance[INJECTOR] = injector;\r\n    }\r\n    return instance;\r\n  });\r\n}\r\n\r\n/**\r\n * Bind type to specified factory funciton.\r\n * @param {any} depsOrFactory Dependencies or factory\r\n * @param {Function} [factory] Factory\r\n * @return {Function}\r\n */\r\nexport function toFactory(depsOrFactory, factory) {\r\n  if (__DEV__) {\r\n    if (factory) {\r\n      if (!Array.isArray(depsOrFactory)) {\r\n        logError(`Dependency array ${getDebugName(depsOrFactory)} is invalid`);\r\n      }\r\n      if (!isFunction(factory)) {\r\n        logError(`Factory ${getDebugName(factory)} is not a valid dependency`);\r\n      }\r\n    } else if (!isFunction(depsOrFactory)) {\r\n      logError(\r\n        `Factory ${getDebugName(depsOrFactory)} is not a valid dependency`\r\n      );\r\n    }\r\n  }\r\n  return asBinding(\r\n    factory\r\n      ? injector =>\r\n          factory(...depsOrFactory.map(token => getInstance(injector, token)))\r\n      : depsOrFactory\r\n  );\r\n}\r\n\r\n/**\r\n * Bind type to specified value.\r\n * @param {any} value\r\n * @return {Function}\r\n */\r\nexport function toValue(value) {\r\n  if (__DEV__) {\r\n    if (value === undefined) {\r\n      logError(`Please specify some value`);\r\n    }\r\n  }\r\n  return asBinding(() => value);\r\n}\r\n\r\n/**\r\n * Bind type to existing instance located by token.\r\n * @param {Token} token\r\n * @return {Function}\r\n */\r\nexport function toExisting(token) {\r\n  if (__DEV__) {\r\n    if (!isFunction(token)) {\r\n      logError(\r\n        `Token ${getDebugName(token)} is not a valid dependency injection token`\r\n      );\r\n    }\r\n  }\r\n  return asBinding(injector => getInstance(injector, token));\r\n}\r\n\r\n/* istanbul ignore next */\r\nconst IS_BINDING = typeof Symbol === \"function\" ? Symbol() : \"__binding__\";\r\n\r\n/**\r\n * Mark function as binding function.\r\n * @internal\r\n * @param {Function} binding\r\n * @returns {Function}\r\n */\r\nfunction asBinding(binding) {\r\n  binding[IS_BINDING] = true;\r\n  return binding;\r\n}\r\n\r\n/**\r\n * Add bindings to bindings Map\r\n * @internal\r\n * @param {Map<Token, Function>} bindingMap\r\n * @param {Definition[]} definitions\r\n */\r\nexport function addBindings(bindingMap, definitions) {\r\n  definitions.forEach(definition => {\r\n    let token, binding;\r\n    if (Array.isArray(definition)) {\r\n      [token, binding = token] = definition;\r\n    } else {\r\n      token = binding = definition;\r\n    }\r\n    if (__DEV__) {\r\n      if (!isToken(token) || !isFunction(binding)) {\r\n        logIncorrectBinding(token, binding);\r\n      }\r\n    }\r\n    // @ts-ignore\r\n    bindingMap.set(token, binding[IS_BINDING] ? binding : toClass(binding));\r\n  });\r\n}\r\n","import { createElement } from \"react\";\r\nimport hoistNonReactStatics from \"hoist-non-react-statics\";\r\nimport { Injector, InjectorContext, registrationQueue } from \"./injector\";\r\nimport { addBindings } from \"./bindings\";\r\nimport { isObject, isFunction } from \"./types\";\r\nimport { logError, getDebugName } from \"./errors\";\r\n/** @typedef {import(\"./types\").Definition} Definition */\r\n/** @typedef {import(\"./types\").Token} Token */\r\n\r\n/**\r\n * HOC that registers dependency injection bindings in scope of decorated component\r\n * @param {...Definition} definitions Dependency injection configuration\r\n */\r\nexport const provider = (...definitions) => Wrapped => {\r\n  /** @type {Map<Token, Function>} */\r\n  const bindingMap = new Map();\r\n\r\n  addBindings(bindingMap, definitions);\r\n\r\n  class Provider extends Injector {\r\n    _parent = this.context;\r\n    _bindingMap = bindingMap;\r\n    _instanceMap = new Map();\r\n\r\n    componentWillUnmount() {\r\n      this._instanceMap.forEach(instance => {\r\n        if (isObject(instance) && isFunction(instance.dispose)) {\r\n          instance.dispose();\r\n        }\r\n      });\r\n    }\r\n\r\n    render() {\r\n      return createElement(\r\n        InjectorContext.Provider,\r\n        { value: this },\r\n        createElement(Wrapped, this.props)\r\n      );\r\n    }\r\n\r\n    static WrappedComponent = Wrapped;\r\n\r\n    /**\r\n     * Register dependency injection bindings in scope of decorated class\r\n     * @param {...Definition} definitions Dependency injection configuration\r\n     */\r\n    static register(...definitions) {\r\n      addBindings(bindingMap, definitions);\r\n    }\r\n  }\r\n\r\n  if (__DEV__) {\r\n    Provider.displayName = `Provider(${Wrapped.displayName || Wrapped.name})`;\r\n\r\n    Object.defineProperty(Provider, \"contextType\", {\r\n      get() {\r\n        return InjectorContext;\r\n      },\r\n      set() {\r\n        logError(\r\n          `You are trying to overwrite ${\r\n            Provider.displayName\r\n          }.contextType = InjectorContext`\r\n        );\r\n      }\r\n    });\r\n  } else {\r\n    Provider.contextType = InjectorContext;\r\n  }\r\n\r\n  // static fields from component should be visible on the generated Consumer\r\n  return hoistNonReactStatics(Provider, Wrapped);\r\n};\r\n\r\n/**\r\n * Register class in specified provider.\r\n * @typedef {{ register(constructor: Function): void }} Provider\r\n * @param {() => Provider} getProvider Function that returns some provider\r\n */\r\nexport const registerIn = getProvider => constructor => {\r\n  registrationQueue.push(() => {\r\n    if (__DEV__) {\r\n      const provider = getProvider();\r\n      if (!isFunction(provider) || !(provider.prototype instanceof Injector)) {\r\n        logError(\r\n          `${getDebugName(provider)} is not a valid Provider. Please use:\\n` +\r\n            `@registerIn(() => MyProvider)\\n` +\r\n            `class ${getDebugName(constructor)} {}\\n`\r\n        );\r\n      } else {\r\n        provider.register(constructor);\r\n      }\r\n    } else {\r\n      getProvider().register(constructor);\r\n    }\r\n  });\r\n  return constructor;\r\n};\r\n","import { useContext, useRef } from \"react\";\r\nimport { InjectorContext, getInstance } from \"./injector\";\r\nimport { logNotFoundProvider } from \"./errors\";\r\n/** @typedef {import(\"./types\").Token} Token */\r\n\r\n/**\r\n * React hook for resolving a class instance that registered by some Provider in hierarchy.\r\n * Instance is cached in Provider that registers it's class.\r\n * @param {Token} token Dependency injection token\r\n * @returns {Object} Resolved class instance\r\n */\r\nexport function useInstance(token) {\r\n  const ref = useRef(null);\r\n  const injector = useContext(InjectorContext);\r\n  if (__DEV__) {\r\n    if (!injector) {\r\n      logNotFoundProvider();\r\n    }\r\n  }\r\n  return ref.current || (ref.current = getInstance(injector, token));\r\n}\r\n\r\n/**\r\n * React hook for resolving a class instances that registered by some Provider in hierarchy.\r\n * Instances are cached in Provider that registers it's classes.\r\n * @param {...Token} tokens Dependency injection tokens\r\n * @returns {Object[]} Resolved class instances\r\n */\r\nexport function useInstances(...tokens) {\r\n  const ref = useRef(null);\r\n  const injector = useContext(InjectorContext);\r\n  if (__DEV__) {\r\n    if (!injector) {\r\n      logNotFoundProvider();\r\n    }\r\n  }\r\n  return (\r\n    ref.current ||\r\n    (ref.current = tokens.map(token => getInstance(injector, token)))\r\n  );\r\n}\r\n"],"names":["isFunction","arg","isObject","InjectorContext","createContext","tslib_1.__extends","Component","getInjector","target","injector","INJECTOR","currentInjector","context","Injector","Symbol","getInstance","token","registrationQueue","length","forEach","registration","instance","_instanceMap","get","undefined","binding","_bindingMap","prevInjector","set","_parent","inject","targetOrToken","keyOrToken","injectFunction","injectDecorator","prototype","key","constructor","contextType","Reflect","getMetadata","descriptor","configurable","enumerable","this","Object","defineProperty","writable","value","toClass","asBinding","toFactory","depsOrFactory","factory","map","toValue","toExisting","IS_BINDING","addBindings","bindingMap","definitions","definition","Array","isArray","_a","provider","_i","Wrapped","Map","_this","Provider","dispose","createElement","props","hoistNonReactStatics","registerIn","getProvider","push","register","useInstance","ref","useRef","useContext","current","useInstances","tokens"],"mappings":"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"}